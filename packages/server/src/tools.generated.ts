/**
 * This file is auto-generated by yarn generate:mcp-tools
 * DO NOT EDIT THIS FILE MANUALLY
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';

export type ToolCallOpenApiOperation = {
  name: string;
  path: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  input: Record<string, any>;
  pathParamKeys?: Array<string>;
  queryParamKeys?: Array<string>;
};

export type ToolCallOpenApiRequestConfig = {
  url: string;
  headers: Record<string, string>;
  body?: string | null | undefined;
  method: ToolCallOpenApiOperation['method'];
};

export type ExecuteToolCallOpenApiOperationCbPayload = ToolCallOpenApiRequestConfig & {
  operation: ToolCallOpenApiOperation;
};

export type ExecuteToolCallOpenApiOperationCb = (
  payload: ExecuteToolCallOpenApiOperationCbPayload,
) => Promise<any>;

function toQueryParams(obj: Record<string, any>): string {
  const params = new URLSearchParams();

  for (const key in obj) {
    const value = obj[key];

    if (value == null) {
      continue;
    }

    if (Array.isArray(value)) {
      value.forEach((v) => params.append(key, String(v)));
    } else if (typeof value === 'object') {
      params.append(key, JSON.stringify(value));
    } else {
      params.append(key, String(value));
    }
  }

  const str = params.toString();

  if (str === '') {
    return '';
  }

  return `?${str}`;
}

export const prepareToolCallOperation = (
  operation: ToolCallOpenApiOperation,
): ExecuteToolCallOpenApiOperationCbPayload => {
  const queryParamKeys = new Set(operation.queryParamKeys ?? []);
  const pathParamKeys = new Set(operation.pathParamKeys ?? []);

  const queryParams: Record<string, string> = {};
  const pathParams: Record<string, string> = {};
  const body: Record<string, any> = {};
  const headers: HeadersInit = {};

  for (const [key, value] of Object.entries(operation.input)) {
    if (queryParamKeys.has(key)) {
      queryParams[key] = value;
    } else if (pathParamKeys.has(key)) {
      pathParams[key] = value;
    } else {
      body[key] = value;
    }
  }

  let resolvedPath = operation.path;

  for (const paramKey of pathParamKeys) {
    resolvedPath = resolvedPath.replace(
      `{${paramKey}}`,
      encodeURIComponent(pathParams[paramKey] ?? ''),
    );
  }

  if (Object.keys(body).length > 0) {
    headers['Accept'] = 'application/json';
    headers['Content-Type'] = 'application/json';
  }

  const url = `${resolvedPath}${toQueryParams(queryParams)}`;

  return {
    url,
    headers,
    body: Object.keys(body).length > 0 ? JSON.stringify(body) : undefined,
    method: operation.method,
    operation,
  };
};

export type OpenAPIToolRuntimeConfigOpts = {
  // basic configuration
  url?: string;
  fetch?: (...args: any[]) => Promise<any>;
  headers?: Record<string, string>;

  // custom implementation of the tool call
  executeToolCall?: ExecuteToolCallOpenApiOperationCb;
  normalizeResponse?: Record<string, (response: any) => CallToolResult>;
};

export class OpenAPIToolRuntimeConfig {
  config: OpenAPIToolRuntimeConfigOpts;

  constructor(config: OpenAPIToolRuntimeConfigOpts) {
    this.config = config;
  }

  private async defaultExecuteToolCall(payload: ExecuteToolCallOpenApiOperationCbPayload) {
    const response = await this.fetch(`${this.baseUrl}${payload.url}`, {
      method: payload.method,
      body: payload.body,
      headers: {
        ...payload.headers,
        ...this.config.headers,
      },
    });

    return await response.json();
  }

  async executeToolCall(operation: ToolCallOpenApiOperation): Promise<CallToolResult> {
    const payload = prepareToolCallOperation(operation);

    try {
      const response = await (this.config.executeToolCall?.(payload) ??
        this.defaultExecuteToolCall(payload));
      return this.normaliseResponse(operation, response);
    } catch (error) {
      console.error('OPENAPI_TOOL_CALL_ERROR', error);
      throw error;
    }
  }

  private normaliseResponse(operation: ToolCallOpenApiOperation, response: any): CallToolResult {
    const normaliser = this.config.normalizeResponse?.[operation.name];

    if (normaliser) {
      return normaliser(response);
    }

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(response),
        },
      ],
    };
  }

  get baseUrl() {
    if (this.config.url) {
      return this.config.url;
    }

    throw new Error('"url" is not defined');
  }

  get fetch() {
    const fetch = this.config.fetch ?? window['fetch'];

    if (!fetch) {
      throw new Error('fetch is not defined');
    }

    return fetch.bind(fetch);
  }
}

export const setupTools = (server: McpServer, opts: OpenAPIToolRuntimeConfigOpts) => {
  const config = new OpenAPIToolRuntimeConfig(opts);

  server.tool(
    'workspaceCreateProject',
    'Create a project in a workspace',
    z.object({
      contentType: z.literal('text/markdown').optional(),
      content: z.string().optional(),
      workspaceId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'workspaceCreateProject',
        path: '/workspaces/{workspaceId}/projects',
        method: 'POST',
        input: args,
        pathParamKeys: ['workspaceId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'workspacesGet',
    'Get all workspaces for a user',
    z.object({}).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'workspacesGet',
        path: '/workspaces',
        method: 'GET',
        input: args,
        pathParamKeys: [],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'workspaceFoldersGet',
    'Get all folders for a workspace',
    z.object({ workspaceId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'workspaceFoldersGet',
        path: '/workspaces/{workspaceId}/folders',
        method: 'GET',
        input: args,
        pathParamKeys: ['workspaceId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'projectGet',
    'Get project',
    z.object({ projectId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'projectGet',
        path: '/projects/{projectId}',
        method: 'GET',
        input: args,
        pathParamKeys: ['projectId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'projectCopy',
    'Copy a project to a folder',
    z.object({
      folderId: z.string().min(1).optional(),
      projectTitle: z.string().min(1).optional(),
      projectId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'projectCopy',
        path: '/projects/{projectId}/copy',
        method: 'POST',
        input: args,
        pathParamKeys: ['projectId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'projectCreate',
    'Create a project in a team',
    z.object({
      folderId: z.string().min(1).optional(),
      contentType: z.literal('text/markdown').optional(),
      content: z.string().optional(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'projectCreate',
        path: '/projects',
        method: 'POST',
        input: args,
        pathParamKeys: [],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'projectBlocksGet',
    'Get all blocks for a project',
    z.object({
      projectId: z.string(),
      limit: z.number().default(100),
      after: z.string().uuid().optional(),
      before: z.string().uuid().optional(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'projectBlocksGet',
        path: '/projects/{projectId}/blocks',
        method: 'GET',
        input: args,
        pathParamKeys: ['projectId'],
        queryParamKeys: ['limit', 'after', 'before'],
      });
    },
  );
  server.tool(
    'projectTasksGet',
    'Get all tasks for a project',
    z.object({
      projectId: z.string(),
      limit: z.number().default(100),
      after: z.string().uuid().optional(),
      before: z.string().uuid().optional(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'projectTasksGet',
        path: '/projects/{projectId}/tasks',
        method: 'GET',
        input: args,
        pathParamKeys: ['projectId'],
        queryParamKeys: ['limit', 'after', 'before'],
      });
    },
  );
  server.tool(
    'taskGet',
    'Get task with id',
    z.object({ projectId: z.string(), taskId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskGet',
        path: '/projects/{projectId}/tasks/{taskId}',
        method: 'GET',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskPut',
    'Update task.',
    z.object({
      contentType: z.enum(['text/markdown', 'text/plain']).optional(),
      content: z.string().regex(new RegExp('^[^\\r\\n]*$')).max(2000).optional(),
      projectId: z.string(),
      taskId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskPut',
        path: '/projects/{projectId}/tasks/{taskId}',
        method: 'PUT',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskComplete',
    'Complete a task in a project',
    z.object({ projectId: z.string(), taskId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskComplete',
        path: '/projects/{projectId}/tasks/{taskId}/complete',
        method: 'POST',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskCreate',
    'Create one or more tasks in a project',
    z.object({
      tasks: z
        .array(
          z.intersection(
            z.object({
              contentType: z.enum(['text/markdown', 'text/plain']),
              content: z.string().max(2000),
            }),
            z.union([
              z
                .object({
                  taskId: z.literal('null').optional(),
                  placement: z.enum(['afterbegin', 'beforeend']),
                })
                .strict(),
              z
                .object({
                  taskId: z.string(),
                  placement: z.enum(['beforebegin', 'afterbegin', 'beforeend', 'afterend']),
                })
                .strict(),
            ]),
          ),
        )
        .max(20)
        .optional(),
      projectId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskCreate',
        path: '/projects/{projectId}/tasks/',
        method: 'POST',
        input: args,
        pathParamKeys: ['projectId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskMove',
    'Move a task within the project',
    z.object({
      target: z
        .object({
          taskId: z.string().min(1),
          position: z.enum(['beforebegin', 'afterbegin', 'beforeend', 'afterend']),
        })
        .strict()
        .optional(),
      projectId: z.string(),
      taskId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskMove',
        path: '/projects/{projectId}/tasks/{taskId}/move',
        method: 'PUT',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskAssigneesGet',
    'Get the assignees of a task',
    z.object({ projectId: z.string(), taskId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskAssigneesGet',
        path: '/projects/{projectId}/tasks/{taskId}/assignees',
        method: 'GET',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskPutAssignees',
    'Task assignment',
    z.object({
      handles: z.array(z.string().min(1)).optional(),
      projectId: z.string(),
      taskId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskPutAssignees',
        path: '/projects/{projectId}/tasks/{taskId}/assignees',
        method: 'PUT',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskDeleteAssignees',
    'Remove assignee from a task',
    z.object({
      projectId: z.string(),
      taskId: z.string(),
      assigneeHandle: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskDeleteAssignees',
        path: '/projects/{projectId}/tasks/{taskId}/assignees/{assigneeHandle}',
        method: 'DELETE',
        input: args,
        pathParamKeys: ['projectId', 'taskId', 'assigneeHandle'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskGetDate',
    'Get the date of a task',
    z.object({ projectId: z.string(), taskId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskGetDate',
        path: '/projects/{projectId}/tasks/{taskId}/date',
        method: 'GET',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskDeleteDate',
    'Delete date of a task',
    z.object({ projectId: z.string(), taskId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskDeleteDate',
        path: '/projects/{projectId}/tasks/{taskId}/date',
        method: 'DELETE',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskPutDate',
    'Create or update date for a task',
    z.object({
      start: z
        .object({
          date: z.string().regex(new RegExp('^\\d{4}-\\d{2}-\\d{2}$')),
          time: z
            .union([
              z.string().regex(new RegExp('^(?:[0-1][0-9]|[2][0-3]):[0-5][0-9](?::[0-5][0-9])?$')),
              z.null(),
            ])
            .optional(),
          timezone: z.union([z.string(), z.null()]).optional(),
        })
        .strict()
        .optional(),
      end: z
        .object({
          date: z.string().regex(new RegExp('^\\d{4}-\\d{2}-\\d{2}$')),
          time: z
            .union([
              z.string().regex(new RegExp('^(?:[0-1][0-9]|[2][0-3]):[0-5][0-9](?::[0-5][0-9])?$')),
              z.null(),
            ])
            .optional(),
          timezone: z.union([z.string(), z.null()]).optional(),
        })
        .strict()
        .optional(),
      projectId: z.string(),
      taskId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskPutDate',
        path: '/projects/{projectId}/tasks/{taskId}/date',
        method: 'PUT',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'taskNotePut',
    'Add/update a note to the task',
    z.object({
      type: z.enum(['text/plain', 'text/markdown']).optional(),
      value: z.string().regex(new RegExp('^[^\\r\\n]*$')).min(1).optional(),
      projectId: z.string(),
      taskId: z.string(),
    }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'taskNotePut',
        path: '/projects/{projectId}/tasks/{taskId}/note',
        method: 'PUT',
        input: args,
        pathParamKeys: ['projectId', 'taskId'],
        queryParamKeys: [],
      });
    },
  );
  server.tool(
    'folderProjectsGet',
    'Get all projects in a team, or in the home team of a workspace.',
    z.object({ folderId: z.string() }).shape,
    async (args) => {
      return await config.executeToolCall({
        name: 'folderProjectsGet',
        path: '/folders/{folderId}/projects',
        method: 'GET',
        input: args,
        pathParamKeys: ['folderId'],
        queryParamKeys: [],
      });
    },
  );
};
