import { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from "openapi-types"
import { ParsedTool, parseOpenApi } from "./parser";
import { jsonSchemaToZod } from "json-schema-to-zod";
import fs from "fs";
import prettier from "prettier";

type IsActionsEnabledOpt = Array<string> | ((actionName: string) => boolean);

type ActionConfig = Partial<{
    title: string;
    description: string;
    normalizer: (args: any) => any;
}>

const isActionsEnabled = (isActionsEnabledOpt: IsActionsEnabledOpt, actionName: string) => {
    if (typeof isActionsEnabledOpt === 'function') {
        return isActionsEnabledOpt(actionName);
    }
    return isActionsEnabledOpt.includes(actionName);
}


const generateToolInputFromParsedTool = (tool: ParsedTool) => {
    const mergedSchema = JSON.parse(JSON.stringify(tool.inputSchema));
    mergedSchema.properties = {
        ...mergedSchema.properties,
        ...tool.pathParamsSchema?.properties,
        ...tool.queryParamsSchema?.properties,
    };
    mergedSchema.required = [
        ...mergedSchema.required,
        ...(tool.pathParamsSchema?.required ?? []),
        ...(tool.queryParamsSchema?.required ?? []),
    ];

    return `${jsonSchemaToZod(mergedSchema)}.shape`;
};


type CodegenOpts = {
    path?: string;
    document: OpenAPIV3_1.Document | OpenAPIV3.Document | OpenAPIV2.Document<{}>;
    isActionsEnabled?: IsActionsEnabledOpt;
    actions?: Record<string, ActionConfig>;
}

export const codegen = async (opts: CodegenOpts) => {
    const { document, path: outputPath } = opts;

    const tools = parseOpenApi(document.paths ?? {});

    let output: string = `
    /**
     * This file is auto-generated by yarn generate:mcp-tools
     * DO NOT EDIT THIS FILE MANUALLY
     */
  
      import { z } from "zod";
      import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

      export type CallOperationOpts = {
        path: string;
        method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
        input: Record<string, any>;
        pathParamKeys?: Array<string>;
        queryParamKeys?: Array<string>;
      };

      export const setupTools = (server: McpServer, callOperation: (opts: CallOperationOpts) => Promise<any>) => {
    `;

    tools.forEach((tool) => {
        if (opts.isActionsEnabled && !isActionsEnabled(opts.isActionsEnabled, tool.name)) {
            return;
        }

        const annotations: Record<string, any> = {};

        if (opts.actions?.[tool.name]) {
            annotations.title = opts.actions[tool.name].title;
            annotations.description = opts.actions[tool.name].description;
        }
        

        const toolArgs = [`"${tool.name}"`, `"${tool.description}"`, generateToolInputFromParsedTool(tool)];

        if ( Object.keys(annotations).length > 0) { 
            toolArgs.push(JSON.stringify(annotations));
        }


        toolArgs.push(`async (args) => {
              const response = await callOperation({
                path: "${tool.path}",
                method: "${tool.method.toUpperCase()}",
                input: args,
                pathParamKeys: ${tool.pathParamsSchema
                ? `[${Object.keys(tool.pathParamsSchema.properties ?? {})
                    .map((r) => `"${r}"`)
                    .join(',')}]`
                : '[]'
            },
                queryParamKeys: ${tool.queryParamsSchema
                ? `[${Object.keys(tool.queryParamsSchema.properties ?? {})
                    .map((r) => `"${r}"`)
                    .join(',')}]`
                : '[]'
            },
              });
    
    
              return {
                content: [
                  {
                    type: 'text',
                    text: JSON.stringify(response),
                  },
                ],
              }
        }`);

        output += `server.tool(${toolArgs.join(',')});\n`;
    });

    output += `
    }
    `;

    const formattedOutput = await prettier.format(output, { parser: 'typescript' });

    if (outputPath) {
        fs.writeFileSync(outputPath, formattedOutput);
    }

    return formattedOutput;
}